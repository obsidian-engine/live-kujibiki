<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>配信用くじ引き</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              'noto': ['Noto Sans JP', 'Inter', 'system-ui', '-apple-system', 'sans-serif']
            }
          }
        }
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      .tab-btn {
        color: #6b7280;
        background-color: transparent;
      }
      .tab-btn.active {
        color: #1f2937;
        background-color: #f3f4f6;
        box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      }
    </style>
  </head>
  <body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 font-noto">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
      <!-- ヘッダー -->
      <div class="text-center mb-8">
        <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-2">🎲 配信用くじ引き</h1>
      </div>

      <!-- タブナビゲーション -->
      <nav class="flex justify-center mb-8" role="tablist">
        <div class="bg-white rounded-xl shadow-sm p-1 inline-flex">
          <button 
            id="playTab" 
            class="tab-btn active px-6 py-3 rounded-lg font-medium text-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            role="tab" 
            aria-selected="true" 
            aria-controls="play-panel"
            onclick="switchTab('play')"
          >
            🎮 <span class="hidden sm:inline ml-1">ゲーム</span>
          </button>
          <button 
            id="masterTab" 
            class="tab-btn px-6 py-3 rounded-lg font-medium text-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            role="tab" 
            aria-selected="false" 
            aria-controls="master-panel"
            onclick="switchTab('master')"
          >
            🛠️ <span class="hidden sm:inline ml-1">設定</span>
          </button>
        </div>
      </nav>

      <!-- ゲームタブ -->
      <div id="play-panel" class="tab-content active" role="tabpanel" aria-labelledby="playTab">
        <div class="bg-white rounded-2xl shadow-xl p-6 md:p-8">
          <!-- 参加者情報表示 -->
          <div class="mb-6 text-center">
            <div class="text-2xl md:text-3xl font-bold text-gray-800 mb-2">
              参加者: <span id="playersView" class="text-blue-600">-</span>人 | 
              現在: <span id="currentView" class="text-green-600">-</span> | 
              残り: <span id="remainView" class="text-red-600">-</span>個
            </div>
            <div class="text-sm text-gray-500 space-y-1">
              <div>
                <span class="inline-flex items-center px-3 py-1 rounded-full bg-gray-100">
                  Room: <span id="roomIdView" class="ml-1 font-medium">-</span>
                </span>
              </div>
              <div>
                <span class="inline-flex items-center px-3 py-1 rounded-full bg-blue-50 text-blue-700">
                  上限: <span class="ml-1 font-medium">10個</span>
                </span>
              </div>
            </div>
          </div>
          

          <!-- 操作ボタン -->
          <div class="flex flex-wrap gap-3 justify-center mb-6">
            <button id="drawBtn" class="disabled px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
              🎲 1件 引く
            </button>
            <button id="ackBtn" class="disabled px-6 py-3 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
              ✅ 確認完了
            </button>
            <button id="resetRoundBtn" class="disabled px-6 py-3 bg-gradient-to-r from-amber-500 to-amber-600 text-white rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-offset-2">
              🔄 ラウンドリセット
            </button>
          </div>

          <!-- 結果表示 -->
          <div id="display" class="bg-gradient-to-r from-indigo-50 to-blue-50 border-2 border-indigo-200 rounded-2xl p-8 text-center text-3xl md:text-5xl font-extrabold text-gray-800 min-h-[120px] flex items-center justify-center shadow-inner">
            Ready
          </div>

          <!-- 現在のお題一覧 -->
          <div class="mt-6 bg-gray-50 rounded-xl p-4">
            <h3 class="text-lg font-semibold text-gray-800 mb-3 flex items-center">
              📋 現在のお題一覧
              <span id="gameTabTopicCount" class="ml-2 text-sm bg-blue-100 text-blue-800 px-2 py-1 rounded-full">0件</span>
            </h3>
            <div id="gameTabMasterList" class="bg-white rounded-lg p-4 text-sm max-h-40 overflow-y-auto border border-gray-200 min-h-[60px] flex items-center justify-center text-gray-500">
              お題が登録されていません
            </div>
          </div>

          <!-- 非表示ボタン -->
          <button
            id="resetAllBtn"
            class="disabled hidden"
            style="background: #fee; border: 1px solid #f88;"
          >
            全部初期化
          </button>
          <div class="hidden">
            <button data-setp="4" class="disabled">4人にする</button>
            <button data-setp="5" class="disabled">5人にする</button>
            <button data-setp="6" class="disabled">6人にする</button>
            <button data-setp="7" class="disabled">7人にする</button>
          </div>
        </div>
      </div>

      <!-- Master設定タブ -->
      <div id="master-panel" class="tab-content" role="tabpanel" aria-labelledby="masterTab">
        <div class="bg-white rounded-2xl shadow-xl p-6 md:p-8">
          <div class="max-w-2xl mx-auto">
            <div class="mb-6">
              <h2 class="text-2xl font-bold text-gray-800 mb-3">🛠️ お題設定</h2>
              <p class="text-gray-600 text-sm">
                初回だけMasterに7件を入れてください。<br />
                ※ Master入力後は自動でListへ展開されます。
              </p>
            </div>

            <div class="mb-6">
              <label for="masterInput" class="block text-sm font-medium text-gray-700 mb-2">
                お題一覧を入力
              </label>
              <textarea
                id="masterInput"
                class="w-full h-36 px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 resize-none"
                placeholder="（例）&#10;リーチをかける&#10;鳴かない&#10;字牌を使う&#10;ドラを使う&#10;ピンフであがる&#10;タンヤオであがる&#10;2回以上鳴く"
              ></textarea>
            </div>

            <div class="mb-6 flex justify-center">
              <button id="applyMasterBtn" class="disabled px-8 py-3 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                📋 Masterを登録（自動展開）
              </button>
            </div>
            
            <!-- ラウンド制限設定 -->
            <div class="mb-6 bg-blue-50 rounded-xl p-4">
              <h3 class="text-lg font-semibold text-gray-800 mb-4 flex items-center">
                📊 ラウンド制限設定
              </h3>
              
              <div class="grid grid-cols-1 gap-4">
                <div>
                  <label for="maxDrawsPerRoundInput" class="block text-sm font-medium text-gray-700 mb-2">
                    1ラウンド最大抽選数
                  </label>
                  <input
                    type="number"
                    id="maxDrawsPerRoundInput"
                    min="0"
                    max="20"
                    value="0"
                    aria-describedby="drawLimitHelp"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                  />
                  <p id="drawLimitHelp" class="text-xs text-gray-500 mt-1">1ラウンド最大抽選数（0=無制限、1-20）</p>
                  <p id="drawLimitError" class="text-xs text-red-600 mt-1 hidden"></p>
                </div>
                
                <div class="text-center text-sm text-gray-600">
                  <p><strong>お題数上限:</strong> 10個（固定）</p>
                </div>
              </div>
              
              <div class="mt-4 flex justify-center">
                <button id="applyLimitsBtn" class="disabled px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                  ⚙️ ラウンド制限を適用
                </button>
              </div>
            </div>
            
            <div class="bg-gray-50 rounded-xl p-4">
              <h3 class="text-sm font-medium text-gray-700 mb-3">現在のお題一覧:</h3>
              <div id="masterListDisplay" class="bg-white rounded-lg p-4 text-sm max-h-32 overflow-y-auto border border-gray-200">
                読み込み中...
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 確認モーダル -->
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50" role="dialog" aria-labelledby="modalTitle" aria-describedby="modalDescription">
      <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-md mx-4 transform transition-all duration-200 scale-95">
        <div class="text-center">
          <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-amber-100 mb-4">
            <svg class="h-6 w-6 text-amber-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 19c-.77.833.192 2.5 1.732 2.5z" />
            </svg>
          </div>
          <h3 id="modalTitle" class="text-lg font-semibold text-gray-900 mb-2">ラウンドリセット確認</h3>
          <p id="modalDescription" class="text-sm text-gray-600 mb-6">
            現在のラウンドをリセットします。<br>
            引いたお題は元に戻され、次はプレイヤー1からになります。<br>
            よろしいですか？
          </p>
          <div class="flex gap-3 justify-center">
            <button id="cancelReset" class="px-6 py-2 bg-gray-100 text-gray-700 rounded-lg font-medium hover:bg-gray-200 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
              キャンセル
            </button>
            <button id="confirmReset" class="px-6 py-2 bg-amber-500 text-white rounded-lg font-medium hover:bg-amber-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-offset-2">
              リセット実行
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Firebase設定を環境変数から注入（GitHub Actionsで置換）
      window.FIREBASE_CONFIG = {
        apiKey: "__FIREBASE_API_KEY__",
        authDomain: "__FIREBASE_AUTH_DOMAIN__",
        projectId: "__FIREBASE_PROJECT_ID__",
        storageBucket: "__FIREBASE_STORAGE_BUCKET__",
        messagingSenderId: "__FIREBASE_MESSAGING_SENDER_ID__",
        appId: "__FIREBASE_APP_ID__",
        measurementId: "__FIREBASE_MEASUREMENT_ID__"
      };
    </script>
    <script>
      // タブ切り替え機能
      function switchTab(tabName) {
        // すべてのタブボタンとパネルの状態をリセット
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        document.querySelectorAll('.tab-content').forEach(panel => {
          panel.classList.remove('active');
        });

        // 選択されたタブをアクティブにする
        const selectedTab = document.getElementById(tabName + 'Tab');
        const selectedPanel = document.getElementById(tabName + '-panel');
        
        if (selectedTab && selectedPanel) {
          selectedTab.classList.add('active');
          selectedTab.setAttribute('aria-selected', 'true');
          selectedPanel.classList.add('active');
        }
      }

      // モーダル制御
      function showConfirmModal() {
        const modal = document.getElementById('confirmModal');
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        document.getElementById('confirmReset').focus();
        
        // ESCキーでモーダルを閉じる
        document.addEventListener('keydown', handleModalEscape);
      }

      function hideConfirmModal() {
        const modal = document.getElementById('confirmModal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        document.removeEventListener('keydown', handleModalEscape);
      }

      function handleModalEscape(e) {
        if (e.key === 'Escape') {
          hideConfirmModal();
        }
      }

      // キーボードナビゲーション対応
      document.addEventListener('DOMContentLoaded', function() {
        const tabButtons = document.querySelectorAll('.tab-btn');
        
        tabButtons.forEach((btn, index) => {
          btn.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const nextIndex = e.key === 'ArrowLeft' ? 
                (index - 1 + tabButtons.length) % tabButtons.length :
                (index + 1) % tabButtons.length;
              tabButtons[nextIndex].click();
              tabButtons[nextIndex].focus();
            }
          });
        });

        // モーダルのイベントリスナー（後でセットアップ）
        // resetRound関数が定義された後に設定される

        // モーダルの背景クリックで閉じる
        document.getElementById('confirmModal').addEventListener('click', function(e) {
          if (e.target === this) {
            hideConfirmModal();
          }
        });
      });
    </script>
    
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        onSnapshot,
        runTransaction,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

      const firebaseConfig = window.FIREBASE_CONFIG;

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth(app);

      const qs = new URLSearchParams(location.search);
      const roomId = (qs.get("room") || "demo-room").trim();
      document.getElementById("roomIdView").textContent = roomId;
      const roomRef = doc(db, "rooms", roomId);

      // ローカルストレージキー
      const STORAGE_KEY = `liveKujibiki-master-${roomId}-v1`;

      const DEFAULT_STATE = {
        master: [],
        list: [],
        history: [],
        currentPlayer: 0,
        maxPlayers: 4,
        maxTopics: 10, // お題数の上限
        topicsWarningThreshold: 10, // 警告を出す残り数の閾値
        maxDrawsPerRound: 0, // 1ラウンドでの最大抽選数 (0=無制限)
        roundBuffer: [],
        display: "Ready",
        updatedAt: serverTimestamp(),
        version: 0,
      };

      function clamp(v, lo, hi) {
        return Math.min(hi, Math.max(lo, v));
      }

      // ローカルストレージからmaster値を取得
      function loadMasterFromStorage() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load master from localStorage:", e);
          return [];
        }
      }

      // master値をローカルストレージに保存
      function saveMasterToStorage(master) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(master));
        } catch (e) {
          console.warn("Failed to save master to localStorage:", e);
        }
      }

      // master表示を更新
      function updateMasterDisplay(master) {
        const displayEl = document.getElementById("masterListDisplay");
        const gameTabDisplayEl = document.getElementById("gameTabMasterList");
        const gameTabCountEl = document.getElementById("gameTabTopicCount");
        
        if (!master || master.length === 0) {
          // 設定タブの表示
          if (displayEl) displayEl.textContent = "まだお題が登録されていません";
          
          // ゲームタブの表示
          if (gameTabDisplayEl) gameTabDisplayEl.innerHTML = '<div class="text-center text-gray-500">お題が登録されていません</div>';
          if (gameTabCountEl) gameTabCountEl.textContent = "0件";
          return;
        }
        
        const masterListHTML = master.map((item, i) => `${i + 1}. ${item}`).join("<br>");
        
        // 設定タブの表示
        if (displayEl) displayEl.innerHTML = masterListHTML;
        
        // ゲームタブの表示
        if (gameTabDisplayEl) gameTabDisplayEl.innerHTML = masterListHTML;
        if (gameTabCountEl) gameTabCountEl.textContent = `${master.length}件`;
      }

      async function ensureRoom() {
        const snap = await getDoc(roomRef);
        if (!snap.exists()) {
          await setDoc(roomRef, DEFAULT_STATE);
        }
      }

      // ★ MasterがありListが空なら自動展開（Master→List）
      async function autoPopulateFromMasterIfNeeded() {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(roomRef);
          if (!snap.exists()) return;
          const s = snap.data();
          const master = s.master || [];
          const list = s.list || [];
          if (master.length > 0 && list.length === 0) {
            tx.set(
              roomRef,
              {
                ...s,
                list: [...master],
                roundBuffer: [],
                currentPlayer: 0, // 次はPlayer1から（ボタンは削除済み）
                display: "Ready",
                updatedAt: serverTimestamp(),
                version: (s.version || 0) + 1,
              },
              { merge: true }
            );
          }
        });
      }

      // ==== UI参照 ====
      const authStateEl = document.getElementById("authState");
      const displayEl = document.getElementById("display");
      const playersView = document.getElementById("playersView");
      const currentView = document.getElementById("currentView");
      const remainView = document.getElementById("remainView");

      const drawBtn = document.getElementById("drawBtn");
      const ackBtn = document.getElementById("ackBtn");
      const resetRoundBtn = document.getElementById("resetRoundBtn");
      const resetAllBtn = document.getElementById("resetAllBtn");
      const masterInput = document.getElementById("masterInput");
      const applyMasterBtn = document.getElementById("applyMasterBtn");
      const playerBtns = Array.from(document.querySelectorAll("[data-setp]"));
      const maxDrawsPerRoundInput = document.getElementById("maxDrawsPerRoundInput");
      const applyLimitsBtn = document.getElementById("applyLimitsBtn");

      function enableControls(enabled) {
        const method = enabled ? "remove" : "add";
        [
          // drawBtnは独自制御するので除外
          ackBtn,
          resetRoundBtn,
          resetAllBtn,
          applyMasterBtn,
          applyLimitsBtn,
          ...playerBtns,
        ].forEach((el) => el.classList[method]("disabled"));
        
        // drawBtnは認証状態のみチェック
        if (drawBtn) {
          if (enabled) {
            drawBtn.disabled = false;
          } else {
            drawBtn.disabled = true;
            drawBtn.classList.add("disabled");
          }
        }
      }

      // ==== Firestore Actions ====
      async function drawOne() {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(roomRef);
          const s = snap.exists() ? snap.data() : DEFAULT_STATE;

          let list = [...(s.list || [])];
          if (list.length === 0)
            throw new Error("Listが空です。Masterへお題を入れてください。");

          const maxP = clamp(Number(s.maxPlayers || 4), 1, 7);
          let current = Number(s.currentPlayer || 0);
          current = (current % maxP) + 1;

          // ラウンド抽選数制限チェック
          const maxDrawsPerRound = Number(s.maxDrawsPerRound || 0);
          const roundBuffer = s.roundBuffer || [];
          if (maxDrawsPerRound > 0 && roundBuffer.length >= maxDrawsPerRound) {
            throw new Error(`1ラウンドの抽選数上限（${maxDrawsPerRound}件）に達しています。ラウンドリセットしてください。`);
          }

          const idx = Math.floor(Math.random() * list.length);
          const picked = list.splice(idx, 1)[0];

          const newRoundBuffer = [...roundBuffer, picked];
          const history = [
            { t: new Date(), player: current, picked },
            ...(s.history || []),
          ].slice(0, 200);

          let display = `🎮 Player ${current} → ${picked}`;
          let currentPlayer = current;
          let listAfter = list;
          let roundBufAfter = newRoundBuffer;

          if (current === maxP) {
            // N回で1ゲーム → 減った分を復元して次は1へ
            listAfter = [...list, ...newRoundBuffer];
            roundBufAfter = [];
            currentPlayer = 0;
            display = `🔁Player ${current} → ${picked}`;
          }

          tx.set(
            roomRef,
            {
              ...s,
              list: listAfter,
              roundBuffer: roundBufAfter,
              history,
              currentPlayer,
              display,
              updatedAt: serverTimestamp(),
              version: (s.version || 0) + 1,
            },
            { merge: true }
          );
        });
      }

      // 「お題を確認しました」→ 表示を消す（中身はそのまま）
      async function acknowledgeDisplay() {
        await setDoc(
          roomRef,
          {
            display: "（確認済・非表示）",
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
      }

      // ラウンド手動復元
      async function resetRound() {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(roomRef);
          const s = snap.exists() ? snap.data() : DEFAULT_STATE;
          const restored = [...(s.list || []), ...(s.roundBuffer || [])];
          tx.set(
            roomRef,
            {
              ...s,
              list: restored,
              roundBuffer: [],
              currentPlayer: 0,
              display: "🎲 くじを開始出来ます",
              updatedAt: serverTimestamp(),
              version: (s.version || 0) + 1,
            },
            { merge: true }
          );
        });
      }

      // 全部初期化（Masterは残す）
      async function resetAll() {
        await setDoc(
          roomRef,
          {
            list: [],
            history: [],
            roundBuffer: [],
            currentPlayer: 0,
            display: "Ready",
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
        // Masterがあれば自動でListへ展開
        await autoPopulateFromMasterIfNeeded();
      }

      async function setPlayers(n) {
        n = clamp(Number(n), 1, 7);
        await setDoc(
          roomRef,
          {
            maxPlayers: n,
            currentPlayer: 0, // 人数変更時は次ラウンド先頭へ
            display: `👥 Players = ${n} (next is 1)`,
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
      }

      // リアルタイムバリデーション
      function validateInput(input, min, max, errorElementId) {
        const value = Number(input.value);
        const errorEl = document.getElementById(errorElementId);
        
        if (value < min || value > max) {
          input.classList.add("border-red-500");
          if (errorEl) {
            errorEl.textContent = `${min}から${max}の範囲で入力してください`;
            errorEl.classList.remove("hidden");
          }
          return false;
        } else {
          input.classList.remove("border-red-500");
          if (errorEl) {
            errorEl.textContent = "";
            errorEl.classList.add("hidden");
          }
          return true;
        }
      }

      // ラウンド制限を適用
      async function applyLimits() {
        // バリデーション
        const isValid = validateInput(maxDrawsPerRoundInput, 0, 20, "drawLimitError");
        
        if (!isValid) {
          alert("入力値に誤りがあります。エラーメッセージを確認してください。");
          return;
        }
        
        const maxDrawsPerRound = clamp(Number(maxDrawsPerRoundInput.value || 0), 0, 20);
        
        await setDoc(
          roomRef,
          { 
            maxTopics: 10, // 固定値
            maxDrawsPerRound,
            updatedAt: serverTimestamp() 
          },
          { merge: true }
        );
        alert("ラウンド制限を適用しました");
      }

      // お題数制限チェック
      function checkTopicsLimit(currentCount, maxCount) {
        if (currentCount >= maxCount) {
          throw new Error(`お題数が上限（${maxCount}件）に達しています。既存のお題を削除するか、上限を上げてください。`);
        }
      }


      // 抽選ボタンの状態更新
      function updateDrawButtonState(remainingCount, maxDrawsPerRound, currentDraws) {
        if (!drawBtn) return;
        
        let buttonText = "🎲 1件 引く";
        let isDisabled = false;
        
        if (remainingCount === 0) {
          buttonText = "❌ お題がありません";
          isDisabled = true;
        } else if (maxDrawsPerRound > 0 && currentDraws >= maxDrawsPerRound) {
          buttonText = `🚫 ラウンド上限達成 (${currentDraws}/${maxDrawsPerRound})`;
          isDisabled = true;
        } else if (maxDrawsPerRound > 0) {
          buttonText = `🎲 1件 引く (${currentDraws}/${maxDrawsPerRound})`;
        }
        
        drawBtn.textContent = buttonText;
        
        if (isDisabled) {
          drawBtn.classList.add("disabled");
          drawBtn.setAttribute("aria-disabled", "true");
          drawBtn.style.cursor = "not-allowed";
          drawBtn.style.opacity = "0.6";
          drawBtn.title = buttonText.replace(/🚫|❌/, ''); // 絵文字を除いた説明をツールチップに
        } else {
          drawBtn.classList.remove("disabled");
          drawBtn.removeAttribute("aria-disabled");
          drawBtn.style.cursor = "";
          drawBtn.style.opacity = "";
          drawBtn.title = "";
        }
      }

      // Master登録 → 自動でListへ展開
      async function applyMaster() {
        const text = masterInput.value || "";
        const master = text
          .split(/\r?\n/)
          .map((s) => s.trim())
          .filter(Boolean);
        
        // 制限チェック（固定上限10個）
        try {
          checkTopicsLimit(master.length, 10);
        } catch (error) {
          alert(error.message);
          return;
        }
        
        // ローカルストレージに保存
        saveMasterToStorage(master);
        updateMasterDisplay(master);
        
        await setDoc(
          roomRef,
          { master, updatedAt: serverTimestamp() },
          { merge: true }
        );
        await autoPopulateFromMasterIfNeeded();
        alert("Masterを登録し、Listへ自動展開しました");
      }

      // ==== 匿名サインイン後にUIを起動 ====
      onAuthStateChanged(auth, async (user) => {
        if (!user) {
          if (authStateEl) authStateEl.textContent = "Signing in (anonymous)...";
          await signInAnonymously(auth).catch((e) => {
            if (authStateEl) authStateEl.textContent = "Anonymous sign-in failed: " + e.message;
          });
          return;
        }

        if (authStateEl) authStateEl.textContent = `Signed in (uid: ${user.uid.slice(0, 6)}…)`;
        enableControls(true);

        await ensureRoom();
        await autoPopulateFromMasterIfNeeded();

        // 初期表示でローカルストレージからmaster読み込み
        const storedMaster = loadMasterFromStorage();
        updateMasterDisplay(storedMaster);

        onSnapshot(roomRef, (snap) => {
          if (!snap.exists()) {
            console.log("ドキュメントが存在しません");
            return;
          }
          const s = snap.data();
          console.log("Firestore データ更新:", s);

          if (displayEl) displayEl.textContent = s.display || "Ready";
          if (playersView) playersView.textContent = s.maxPlayers ?? "-";
          const currentPlayerNum = (s.currentPlayer % (s.maxPlayers || 4)) + 1;
          if (currentView) currentView.textContent = `プレイヤー${currentPlayerNum}`;
          const remainingCount = s.list?.length ?? 0;
          console.log("残り個数更新:", remainingCount, "リストデータ:", s.list, "remainView要素:", remainView);
          if (remainView) {
            remainView.textContent = String(remainingCount);
            console.log("remainView要素に設定した値:", remainView.textContent);
          } else {
            console.error("remainView要素が見つかりません");
          }

          // 制限情報の表示更新
          const maxDrawsPerRound = s.maxDrawsPerRound ?? 0;
          const currentDrawsInRound = s.roundBuffer?.length ?? 0;
          
          // 設定画面の入力値を更新
          if (maxDrawsPerRoundInput) maxDrawsPerRoundInput.value = maxDrawsPerRound;
          
          // 抽選ボタンの状態制御
          updateDrawButtonState(remainingCount, maxDrawsPerRound, currentDrawsInRound);

          // FirebaseからmasterデータがあればローカルストレージとUI更新
          if (s.master && s.master.length > 0) {
            saveMasterToStorage(s.master);
            updateMasterDisplay(s.master);
          } else {
            // Firebaseにmasterがない場合はローカルストレージから復元表示
            const stored = loadMasterFromStorage();
            updateMasterDisplay(stored);
          }

          // State表示は削除されたため、この処理をコメントアウト
          // document.getElementById(
          //   "state"
          // ).textContent = `Auth: Signed in / version:${
          //   s.version ?? 0
          // } / updated:${s.updatedAt?.toDate?.().toLocaleString?.() ?? "-"}`;
        });

        // ボタンイベント
        drawBtn.onclick = () => drawOne().catch((e) => alert(e.message));
        ackBtn.onclick = () => acknowledgeDisplay();
        resetRoundBtn.onclick = () => showConfirmModal(); // モーダル表示に変更
        resetAllBtn.onclick = () => resetAll();
        applyMasterBtn.onclick = () => applyMaster().catch((e) => alert(e.message));
        applyLimitsBtn.onclick = () => applyLimits().catch((e) => alert(e.message));
        playerBtns.forEach((btn) => {
          btn.onclick = () => setPlayers(btn.getAttribute("data-setp"));
        });

        // リアルタイムバリデーションのイベントリスナー
        maxDrawsPerRoundInput.addEventListener('input', () => validateInput(maxDrawsPerRoundInput, 0, 20, "drawLimitError"));

        // モーダルのイベントリスナーをここで設定（resetRound関数が利用可能）
        document.getElementById('cancelReset').addEventListener('click', hideConfirmModal);
        document.getElementById('confirmReset').addEventListener('click', async function() {
          hideConfirmModal();
          try {
            await resetRound(); // resetRound関数が参照可能
          } catch (error) {
            console.error('リセット処理でエラーが発生しました:', error);
            alert('リセット処理でエラーが発生しました: ' + error.message);
          }
        });
      });
    </script>
  </body>
</html>
